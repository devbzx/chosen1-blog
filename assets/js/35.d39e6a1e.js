(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{517:function(a,t,s){"use strict";s.r(t);var e=s(13),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"谈谈-jvm-的内存结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈-jvm-的内存结构"}},[a._v("#")]),a._v(" 谈谈 JVM 的内存结构")]),a._v(" "),s("p",[a._v("Java 中对象的引用分为四种级别，这四种级别由高到低依次为："),s("strong",[a._v("强引用、软引用、弱引用和虚引用")]),a._v("。")]),a._v(" "),s("h3",{attrs:{id:"_1-强引用-strongreference"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-强引用-strongreference"}},[a._v("#")]),a._v(" 1）强引用（StrongReference）")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" abc"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"abc"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("如果一个对象被被人拥有"),s("strong",[a._v("强引用")]),a._v("，那么垃圾回收器"),s("strong",[a._v("绝不会回收它")]),a._v("。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。")]),a._v(" "),s("p",[a._v("Java 的对象是位于 heap 中的，heap 中对象有"),s("strong",[a._v("强可及对象")]),a._v("、"),s("strong",[a._v("软可及对象")]),a._v("、"),s("strong",[a._v("弱可及对象")]),a._v("、"),s("strong",[a._v("虚可及对象")]),a._v("和"),s("strong",[a._v("不可到达对象")]),a._v("。应用的强弱顺序是强、软、弱、和虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" abc"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"abc"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//1")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SoftReference")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" softRef"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SoftReference")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("abc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//2")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakReference")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" weakRef "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakReference")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("abc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//3")]),a._v("\nabc"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//4")]),a._v("\nsoftRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("clear")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//5 ")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[a._v("第一行在 heap 堆中创建内容为“abc”的对象，并建立 abc 到该对象的强引用，该对象是强可及的。")]),a._v(" "),s("p",[a._v("第二行和第三行分别建立对 heap 中对象的软引用和弱引用，此时 heap 中的 abc 对象已经有 3 个引用，显然此 时 abc 对象仍是强可及的。")]),a._v(" "),s("p",[a._v("第四行之后 heap 中对象不再是强可及的，变成软可及的。")]),a._v(" "),s("p",[a._v("第五行执行之后变成弱可及的。")]),a._v(" "),s("h3",{attrs:{id:"_2-软引用-softreference"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-软引用-softreference"}},[a._v("#")]),a._v(" 2）软引用（SoftReference）")]),a._v(" "),s("p",[a._v("如果一个对象只具有软引用，那么如果"),s("strong",[a._v("内存空间足够")]),a._v("，垃圾回收器就"),s("strong",[a._v("不会回收它")]),a._v("， 如果"),s("strong",[a._v("内存空间不足")]),a._v("了，就会"),s("strong",[a._v("回收这些对象的内存")]),a._v("。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。")]),a._v(" "),s("p",[a._v("软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。")]),a._v(" "),s("p",[a._v("软引用是主要用于内存敏感的高速缓存。")]),a._v(" "),s("p",[a._v("在 jvm 报告内存不足之前会清除所有的软引用，这样以来 gc 就有 可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于 gc 的算法和 gc 运行 时可用内存的大小。")]),a._v(" "),s("h3",{attrs:{id:"_3-弱引用-weakreference"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-弱引用-weakreference"}},[a._v("#")]),a._v(" 3）弱引用（WeakReference）")]),a._v(" "),s("p",[a._v("如果一个对象只具有弱引用，那该类就是可有可无的对象，因为只要该对象被 gc 扫描到了随时都会把它干掉。")]),a._v(" "),s("p",[a._v("弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。")]),a._v(" "),s("p",[a._v("在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。")]),a._v(" "),s("p",[a._v("弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚 拟机就会把这个弱引用加入到与之关联的引用队列中。")]),a._v(" "),s("h3",{attrs:{id:"_4-虚引用-phantomreference"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-虚引用-phantomreference"}},[a._v("#")]),a._v(" 4）虚引用（PhantomReference）")]),a._v(" "),s("p",[a._v('"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。')]),a._v(" "),s("p",[a._v("如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。")]),a._v(" "),s("p",[a._v("虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。")]),a._v(" "),s("p",[a._v("当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚 引用加入到与之关联的引用队列中。")]),a._v(" "),s("p",[a._v("程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。")]),a._v(" "),s("p",[a._v("程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。")]),a._v(" "),s("p",[a._v("建立虚引用之后通过 get 方法返回结果始终为 null,通过源代码你会发现,虚引用通向会把引用的对象写进 referent,只是 get 方法返回结果为 null。先看一下和 gc 交互的过程再说一下他的作用。")]),a._v(" "),s("p",[a._v('1 不把 referent 设置为 null, 直接把 heap 中的 new String("abc")对象设置为可结束的(finalizable)。')]),a._v(" "),s("p",[a._v("2 与软引用和弱引用不同, 先把 PhantomRefrence 对象添加到它的 ReferenceQueue 中.然后在释放虚可及的对象。")]),a._v(" "),s("p",[a._v("##heap 和 stack 有什么区别")]),a._v(" "),s("h3",{attrs:{id:"_1-申请方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-申请方式"}},[a._v("#")]),a._v(" 1）申请方式")]),a._v(" "),s("h4",{attrs:{id:"stack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stack"}},[a._v("#")]),a._v(" stack")]),a._v(" "),s("p",[a._v("由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间")]),a._v(" "),s("h4",{attrs:{id:"heap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#heap"}},[a._v("#")]),a._v(" heap")]),a._v(" "),s("p",[a._v("需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于 Java 需要手动 new Object()的形式开辟")]),a._v(" "),s("h3",{attrs:{id:"_2-申请后系统的响应"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-申请后系统的响应"}},[a._v("#")]),a._v(" 2）申请后系统的响应")]),a._v(" "),s("h4",{attrs:{id:"stack-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stack-2"}},[a._v("#")]),a._v(" stack")]),a._v(" "),s("p",[a._v("只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。")]),a._v(" "),s("h4",{attrs:{id:"heap-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#heap-2"}},[a._v("#")]),a._v(" heap")]),a._v(" "),s("p",[a._v("首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空 间 分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。")]),a._v(" "),s("h3",{attrs:{id:"_3-申请大小的限制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-申请大小的限制"}},[a._v("#")]),a._v(" 3）申请大小的限制")]),a._v(" "),s("h4",{attrs:{id:"stack-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stack-3"}},[a._v("#")]),a._v(" stack")]),a._v(" "),s("p",[a._v("栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是 系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（也有的说是 1M，总之是一个编译时就确定的常数），如果 申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。")]),a._v(" "),s("h4",{attrs:{id:"heap-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#heap-3"}},[a._v("#")]),a._v(" heap")]),a._v(" "),s("p",[a._v("堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。")]),a._v(" "),s("h3",{attrs:{id:"_4-申请效率的比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-申请效率的比较"}},[a._v("#")]),a._v(" 4）申请效率的比较")]),a._v(" "),s("h4",{attrs:{id:"stack-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stack-4"}},[a._v("#")]),a._v(" stack")]),a._v(" "),s("p",[a._v("由系统自动分配，速度较快。但程序员是无法控制的。")]),a._v(" "),s("h4",{attrs:{id:"heap-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#heap-4"}},[a._v("#")]),a._v(" heap")]),a._v(" "),s("p",[a._v("由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。")]),a._v(" "),s("h3",{attrs:{id:"_5-heap-和-stack-中的存储内容"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-heap-和-stack-中的存储内容"}},[a._v("#")]),a._v(" 5）heap 和 stack 中的存储内容")]),a._v(" "),s("h4",{attrs:{id:"stack-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stack-5"}},[a._v("#")]),a._v(" stack")]),a._v(" "),s("p",[a._v("在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量 是不入栈的。")]),a._v(" "),s("p",[a._v("当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下 一条指令，程序由该点继续运行。")]),a._v(" "),s("h4",{attrs:{id:"heap-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#heap-5"}},[a._v("#")]),a._v(" heap")]),a._v(" "),s("p",[a._v("一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。")]),a._v(" "),s("h3",{attrs:{id:"_6-数据结构层面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-数据结构层面"}},[a._v("#")]),a._v(" 6）数据结构层面")]),a._v(" "),s("p",[a._v("这里的堆实际上指的就是（满足堆性质的）优先队列的一 种数据结构，第 1 个元素有最高的优先权；")]),a._v(" "),s("p",[a._v("栈实际上就是满足先进后出的性质的数学或数据结构。")]),a._v(" "),s("p",[a._v("虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。")]),a._v(" "),s("h2",{attrs:{id:"内存中的栈-stack-、堆-heap-和方法区-method-area"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存中的栈-stack-、堆-heap-和方法区-method-area"}},[a._v("#")]),a._v(" 内存中的栈（stack）、堆（heap）和方法区（method area）")]),a._v(" "),s("p",[a._v("通常我们"),s("strong",[a._v("定义一个基本数据类型的变量，一个对象的引用")]),a._v("，还有就是"),s("strong",[a._v("函数调用的现场保存")]),a._v("都使用 JVM 中的"),s("strong",[a._v("栈空间")]),a._v("；")]),a._v(" "),s("p",[a._v("而通过 "),s("strong",[a._v("new 关键字和构造器创建的对象")]),a._v("则放在"),s("strong",[a._v("堆空间")]),a._v("，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器 都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；")]),a._v(" "),s("p",[a._v("方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载 的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；")]),a._v(" "),s("p",[a._v("程序中的"),s("strong",[a._v("字面量")]),a._v("（literal）如"),s("strong",[a._v('直接书写的 100、"hello" 和常量')]),a._v("都是放在"),s("strong",[a._v("常量池")]),a._v("中，"),s("strong",[a._v("常量池是方法区的一部分")]),a._v("。")]),a._v(" "),s("p",[a._v("栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" str "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"hello"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v('上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的。')])])}),[],!1,null,null,null);t.default=r.exports}}]);