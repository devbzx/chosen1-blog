(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{465:function(v,_,t){"use strict";t.r(_);var s=t(18),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"在开发中遇到过内存溢出么-原因有哪些-解决方法有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在开发中遇到过内存溢出么-原因有哪些-解决方法有哪些"}},[v._v("#")]),v._v(" 在开发中遇到过内存溢出么？原因有哪些？解决方法有哪些？")]),v._v(" "),t("p",[t("strong",[v._v("引起内存溢出的原因有很多种，常见的有以下几种")])]),v._v(" "),t("p",[v._v("1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；")]),v._v(" "),t("p",[v._v("2.集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收；")]),v._v(" "),t("p",[v._v("3.代码中存在死循环或循环产生过多重复的对象实体；")]),v._v(" "),t("p",[v._v("4.使用的第三方软件中的 BUG；")]),v._v(" "),t("p",[v._v("5.启动参数内存值设定的过小；")]),v._v(" "),t("p",[t("strong",[v._v("内存溢出的解决方案")])]),v._v(" "),t("p",[t("strong",[v._v("第一步")]),v._v("，修改 JVM 启动参数，直接增加内存。(-Xms，-Xmx 参数一定不要忘记加。)")]),v._v(" "),t("p",[t("strong",[v._v("第二步")]),v._v("，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。")]),v._v(" "),t("p",[t("strong",[v._v("第三步")]),v._v("，对代码进行走查和分析，找出可能发生内存溢出的位置。")]),v._v(" "),t("p",[t("strong",[v._v("重点排查以下几点")])]),v._v(" "),t("p",[v._v("1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能 引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次 查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。")]),v._v(" "),t("p",[v._v("2.检查代码中是否有死循环或递归调用。")]),v._v(" "),t("p",[v._v("3.检查是否有大循环重复产生新对象实体。")]),v._v(" "),t("p",[v._v("4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能 引起内存溢出。这个问题比较隐蔽，在上线前，数据库中 数据较少，不容易出问题，上线后，数据库中数据多了， 一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。")]),v._v(" "),t("p",[v._v("5.检查 List、MAP 等集合对象是否有使用完后，未清除的问题。List、MAP 等集合对象会始终存有对对象的 引用，使得这些对象不能被 GC 回收。")]),v._v(" "),t("p",[t("strong",[v._v("第四步")]),v._v("，使用内存查看工具动态查看内存使用情况。")])])}),[],!1,null,null,null);_.default=r.exports}}]);